<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercise Posture Detector</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3a0ca3;
            --success: #4cc9f0;
            --warning: #118076;
            --dark: #212529;
            --light: #f8f9fa;
            --gray: #6c757d;
            --transition: all 0.3s ease;
            --shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            --radius: 12px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #118076, #fdbb2d);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            color: var(--light);
            min-height: 100vh;
            overflow-x: hidden;
        }

        @keyframes gradientBG {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
            animation: fadeIn 1s ease;
        }

        header h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        header p {
            font-size: 1.2rem;
            max-width: 600px;
            margin: 0 auto;
            opacity: 0.9;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: var(--radius);
            padding: 30px;
            box-shadow: var(--shadow);
            margin: 20px auto;
            max-width: 500px;
            animation: slideUp 0.8s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .card h2 {
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.8rem;
        }

        select,
        button {
            width: 100%;
            padding: 15px;
            border-radius: 8px;
            border: none;
            font-size: 1.1rem;
            margin-bottom: 20px;
            transition: var(--transition);
        }

        select {
            background: rgba(255, 255, 255, 0.9);
            color: var(--dark);
            cursor: pointer;
        }

        select:focus {
            outline: 2px solid var(--primary);
            transform: scale(1.02);
        }

        button {
            background: var(--primary);
            color: white;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:hover:not(:disabled) {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        button:disabled {
            background: var(--gray);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #stop-btn {
            background: var(--warning);
            max-width: 200px;
            margin: 20px auto;
            display: none;
        }

        #stop-btn:hover {
            background: #d81159;
        }

        /* Exercise View Styles */
        #exercise-view {
            display: none;
        }

        .exercise-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            flex-wrap: wrap;
            gap: 15px;
        }

        .exercise-header h1 {
            font-size: 2.2rem;
        }

        .stats-panel {
            display: flex;
            justify-content: space-around;
            margin: 30px 0;
            flex-wrap: wrap;
            gap: 20px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius);
            padding: 20px;
            text-align: center;
            min-width: 150px;
            box-shadow: var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: pulse 2s infinite;
        }

        .stat-box h3 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            opacity: 0.8;
        }

        .counter {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--success);
        }

        .status {
            font-size: 1.8rem;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 6px;
        }

        .status.good {
            background: rgba(76, 201, 240, 0.2);
            color: var(--success);
        }

        .status.bad {
            background: rgba(247, 37, 133, 0.2);
            color: var(--warning);
        }

        .video-feed {
            text-align: center;
            margin: 30px 0;
            position: relative;
        }

        .video-placeholder {
            position: relative;
            display: inline-block;
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 640px;
        }

        /* Modified video and canvas styling */
        #camera-stream,
        #pose-canvas {
            border-radius: var(--radius);
            transform: scaleX(-1);
            /* Mirror for front camera */
            width: 100%;
            height: auto;
            transition: filter 0.5s ease;
        }

        #camera-stream.blur,
        #pose-canvas.blur {
            filter: blur(8px);
            -webkit-filter: blur(8px);
        }

        /* Person Detection Overlay */
        .person-detection-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: var(--radius);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            /* Allow clicks to pass through */
        }

        .person-detection-overlay.active {
            opacity: 1;
        }

        .overlay-content {
            text-align: center;
            color: white;
            padding: 30px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            max-width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 2px solid var(--warning);
            animation: bounce 2s infinite;
            /* Ensure the overlay content is never blurred */
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .overlay-content i {
            font-size: 4rem;
            margin-bottom: 20px;
            color: var(--warning);
            animation: pulse 1.5s infinite;
        }

        .overlay-content h3 {
            margin-bottom: 15px;
            font-size: 1.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .overlay-content p {
            font-size: 1.2rem;
            line-height: 1.5;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        .feedback-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius);
            padding: 20px;
            margin: 30px 0;
            text-align: center;
            box-shadow: var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .feedback-panel h3 {
            margin-bottom: 15px;
            font-size: 1.4rem;
        }

        .feedback-text {
            font-size: 1.2rem;
            min-height: 30px;
            color: var(--success);
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 201, 240, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(76, 201, 240, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(76, 201, 240, 0);
            }
        }

        /* Mobile Info Panel Styles */
        .mobile-info-panel {
            display: none;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 15px;
            margin: 0 15px;
            z-index: 2;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .info-row:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-weight: bold;
            color: #4cc9f0;
            width: 80px;
        }

        /* Mobile styles */
        @media (max-width: 768px) {

            html,
            body {
                height: 100%;
                margin: 0;
                padding: 0;
                overflow: hidden;
            }

            .container {
                padding: 0;
                height: 100vh;
                max-width: 100%;
                width: 100%;
            }

            #exercise-view {
                height: 100vh;
                display: none;
                /* Keep hidden by default */
                flex-direction: column;
            }

            /* Show exercise view when active */
            #exercise-view.active {
                display: flex;
            }

            /* Fixed header positioning - only visible when exercise is active */
            .exercise-header {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                z-index: 10;
                background: rgba(0, 0, 0, 0.5);
                padding: 10px;
                display: flex;
                justify-content: center;
                align-items: center;
                height: auto;
            }

            .exercise-header h1 {
                font-size: 1.5rem;
                margin: 0;
                text-align: center;
            }

            /* Hide stop button in header on mobile */
            .exercise-header #stop-btn {
                display: none;
            }

            .exercise-container {
                position: relative;
                height: 100vh;
                width: 100%;
                display: flex;
                flex-direction: column;
            }

            .video-feed {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1;
                margin: 0;
            }

            .video-placeholder {
                width: 100%;
                height: 100%;
                border-radius: 0;
                overflow: hidden;
            }

            /* Updated camera and canvas styling for mobile */
            #camera-stream,
            #pose-canvas {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                object-fit: cover;
                border-radius: 0;
                transform: scaleX(-1);
                z-index: 1;
                /* Mirror for front camera */
            }

            /* Hide desktop panels on mobile */
            .stats-panel,
            .feedback-panel {
                display: none;
            }

            /* Show mobile info panel */
            .mobile-info-panel {
                display: block !important;
                position: absolute;
                bottom: 70px;
                left: 0;
                right: 0;
                z-index: 2;
                margin: 0 15px;
                background: rgba(0, 0, 0, 0.7);
                border-radius: 10px;
                padding: 15px;
            }

            .info-row {
                display: flex;
                justify-content: space-between;
                margin-bottom: 8px;
                font-size: 1rem;
            }

            .info-row:last-child {
                margin-bottom: 0;
            }

            .info-label {
                font-weight: bold;
                color: #4cc9f0;
                width: 80px;
            }

            /* Fixed stop button at bottom - only visible when exercise is active */
            #stop-btn {
                position: fixed;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 20;
                max-width: 90%;
                width: 90%;
                margin: 0;
                display: none;
                /* Keep hidden by default */
            }

            /* Show stop button when exercise is active */
            #exercise-view.active #stop-btn {
                display: block;
            }

            .loader,
            .camera-permission {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 100;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }

            .person-detection-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 3;
            }

            .overlay-content {
                background: rgba(0, 0, 0, 0.8);
                padding: 20px;
                border-radius: 10px;
                max-width: 90%;
            }

            .overlay-content i {
                font-size: 3rem;
            }

            .overlay-content h3 {
                font-size: 1.5rem;
            }

            .overlay-content p {
                font-size: 1rem;
            }
        }

        /* Loading Animation */
        .loader {
            display: none;
            text-align: center;
            margin: 30px 0;
        }

        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 5px solid var(--primary);
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Camera Permission Prompt */
        .camera-permission {
            text-align: center;
            padding: 20px;
            background: rgba(247, 37, 133, 0.2);
            border-radius: var(--radius);
            margin: 20px 0;
            display: none;
        }

        .camera-permission i {
            font-size: 3rem;
            margin-bottom: 15px;
            color: var(--warning);
        }

        /* Pulse animation for rep counter */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        #rep-counter-mobile.pulse {
            animation: pulse 0.5s ease-in-out;
            display: inline-block;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Exercise View -->
        <div id="exercise-view">
            <header class="exercise-header">
                <button id="stop-btn">Stop Exercise</button>
            </header>

            <div class="loader">
                <div class="loader-spinner"></div>
                <p>Initializing camera and pose detection...</p>
            </div>

            <div class="camera-permission">
                <i class="fas fa-camera"></i>
                <h3>Camera Access Required</h3>
                <p>Please allow camera access to use the posture detection feature</p>
            </div>

            <main class="exercise-container">
                <div class="stats-panel">
                    <div class="stat-box">
                        <h3 id="counter-label">REPS</h3>
                        <div id="rep-counter" class="counter">0</div>
                    </div>

                    <div class="stat-box">
                        <h3>FORM</h3>
                        <div id="form-status" class="status">OK</div>
                    </div>
                </div>

                <div class="mobile-info-panel">
                    <div class="info-row">
                        <span class="info-label">Exercise:</span>
                        <span id="exercise-name-mobile">Exercise</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label" id="counter-label-mobile">Reps:</span>
                        <span id="rep-counter-mobile">0</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Posture:</span>
                        <span id="form-status-mobile">OK</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Feedback:</span>
                        <span id="feedback-text-mobile">No feedback yet</span>
                    </div>
                </div>

                <div class="video-feed">
                    <div class="video-placeholder">
                        <video id="camera-stream" autoplay playsinline></video>
                        <canvas id="pose-canvas"></canvas>
                        <div class="person-detection-overlay">
                            <div class="overlay-content">
                                <i class="fas fa-user-check"></i>
                                <h3>Position Yourself</h3>
                                <p>Please make sure your entire body is visible in the frame</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="feedback-panel">
                    <h3>FEEDBACK</h3>
                    <div id="feedback-text" class="feedback-text">No feedback yet</div>
                </div>
            </main>
        </div>
    </div>

    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

    <script>
        // Configuration
        const API_BASE_URL = 'https://yalla-ai.onlinetestingserver.com/v1/exercise';
        //const API_BASE_URL = 'https://jamel-unscored-perdurably.ngrok-free.dev/v1/exercise';

        // Global variables
        let ws = null;
        let pose = null;
        let camera = null;
        let sessionId = null;
        let exerciseName = null;
        let personDetected = true;
        let missingFrames = 0;
        const MISSING_THRESHOLD = 0;
        let exerciseActive = false; // Flag to track if exercise is active

        // Camera jerk detection variables
        let lastKeypoints = null;
        let lastFrameTimestamp = null;
        let cameraJerkThreshold = 0.2;
        let isCameraJerk = false;
        let jerkRecoveryFrames = 0;
        const JERK_RECOVERY_COUNT = 30;

        // Whole body detection variables
        const bodyVisibilityThreshold = 0.7; // 70% of key points must be visible
        const keyPointVisibilityThreshold = 0.5; // Each key point must be at least 50% visible
        let wholeBodyDetected = false;

        // Camera ready flags
        let cameraReady = false;
        let firstPoseResultReceived = false;
        
        // Timer variables for plank exercises
        let timerInterval = null;
        let elapsedTime = 0; // in milliseconds
        let timerRunning = false;
        let isPlankExercise = false;
        let lastTimerUpdate = 0;
        let overlayActive = false; // Track if overlay is active
        const validPlankFeedbacks = [
            "good form",
            "Hips too high - lower them!",
            "Hips sagging - lift them up!",
            "Doing Good Keep it"
        ];

        // DOM Elements
        const exerciseView = document.getElementById('exercise-view');
        const stopBtn = document.getElementById('stop-btn');
        const repCounter = document.getElementById('rep-counter');
        const formStatus = document.getElementById('form-status');
        const feedbackText = document.getElementById('feedback-text');
        const cameraStream = document.getElementById('camera-stream');
        const poseCanvas = document.getElementById('pose-canvas');
        const loader = document.querySelector('.loader');
        const cameraPermission = document.querySelector('.camera-permission');
        const personDetectionOverlay = document.querySelector('.person-detection-overlay');
        const videoPlaceholder = document.querySelector('.video-placeholder');
        const counterLabel = document.getElementById('counter-label');
        const counterLabelMobile = document.getElementById('counter-label-mobile');

        // Check if whole body is visible
        function isWholeBodyVisible(landmarks) {
            if (!landmarks || landmarks.length === 0) return false;

            // Key points for whole body detection (head, shoulders, elbows, wrists, hips, knees, ankles)
            const keyPointIndices = [
                0,   // nose
                11,  // left shoulder
                12,  // right shoulder
                13,  // left elbow
                14,  // right elbow
                15,  // left wrist
                16,  // right wrist
                23,  // left hip
                24,  // right hip
                25,  // left knee
                26,  // right knee
                27,  // left ankle
                28   // right ankle
            ];

            let visiblePoints = 0;
            const totalPoints = keyPointIndices.length;

            for (const index of keyPointIndices) {
                if (index < landmarks.length) {
                    const landmark = landmarks[index];
                    if (landmark.visibility >= keyPointVisibilityThreshold) {
                        visiblePoints++;
                    }
                }
            }

            // Calculate visibility percentage
            const visibilityPercentage = visiblePoints / totalPoints;

            return visibilityPercentage >= bodyVisibilityThreshold;
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            //createMobileDebugConsole();
            
            // Parse URL parameters to get session ID and exercise name
            const urlParams = new URLSearchParams(window.location.search);
            const urlSessionId = urlParams.get('session_id');
            const urlExerciseName = urlParams.get('exercise');
            // Check if we have the required parameters in the URL
            if (urlSessionId && urlExerciseName) {
                // Use the parameters from the URL
                sessionId = urlSessionId;
                exerciseName = urlExerciseName.toLowerCase(); // Convert to lowercase for consistent comparison
                
                // Check if this is a plank exercise
                isPlankExercise = exerciseName.includes('plank');
                
                // Update UI based on exercise type
                if (isPlankExercise) {
                    counterLabel.textContent = 'TIME';
                    counterLabelMobile.textContent = 'Time:';
                }
                
                exerciseActive = true;

                // Show exercise view and initialize
                showExerciseView();
                initializeExercise();
            } else {
                // If no URL params, show an error
                showError("No session information found. Please provide a valid session ID and exercise name in the URL.");
            }

            // Set up event listener for stop button
            stopBtn.addEventListener('click', stopExercise);
        });

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.style.position = 'fixed';
            errorDiv.style.top = '50%';
            errorDiv.style.left = '50%';
            errorDiv.style.transform = 'translate(-50%, -50%)';
            errorDiv.style.background = '#282828';
            errorDiv.style.color = 'white';
            errorDiv.style.padding = '20px';
            errorDiv.style.borderRadius = '10px';
            errorDiv.style.textAlign = 'center';
            errorDiv.style.zIndex = '1000';
            errorDiv.style.width = '80%';
            errorDiv.innerHTML = `<h3>Error</h3><p>${message}</p>`;

            document.body.appendChild(errorDiv);

            // Add a close button
            const closeButton = document.createElement('button');
            closeButton.textContent = 'Close';
            closeButton.style.marginTop = '20px';
            closeButton.style.backgroundColor = '#118076';
            closeButton.onclick = function () {
                window.ReactNativeWebView.postMessage(JSON.stringify({ event: "stop_exercise" }))
                document.body.removeChild(errorDiv);
            };

            errorDiv.appendChild(closeButton);
        }

        // Reset exercise state
        function resetExerciseState() {
            // Reset UI elements
            repCounter.textContent = "0";
            formStatus.textContent = "OK";
            formStatus.className = "status good";
            feedbackText.textContent = "No feedback yet";

            // Reset mobile UI elements
            const mobileRepCounter = document.getElementById('rep-counter-mobile');
            const mobileFormStatus = document.getElementById('form-status-mobile');
            const mobileFeedbackText = document.getElementById('feedback-text-mobile');
            const mobileExerciseName = document.getElementById('exercise-name-mobile');

            if (mobileRepCounter) mobileRepCounter.textContent = "0";
            if (mobileFormStatus) mobileFormStatus.textContent = "OK";
            if (mobileFeedbackText) mobileFeedbackText.textContent = "No feedback yet";
            if (mobileExerciseName) mobileExerciseName.textContent = exerciseName || "Exercise";

            // Reset state variables
            personDetected = true;
            missingFrames = 0;
            wholeBodyDetected = false;
            lastKeypoints = null;
            lastFrameTimestamp = null;
            isCameraJerk = false;
            jerkRecoveryFrames = 0;
            overlayActive = false;

            // Reset overlay and blur
            personDetectionOverlay.classList.remove('active');
            cameraStream.classList.remove('blur');
            poseCanvas.classList.remove('blur');
            
            // Reset timer variables
            elapsedTime = 0;
            timerRunning = false;
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            updateTimerDisplay();
        }

        // Show exercise view with animation
        function showExerciseView() {
            // Show exercise view but keep loader visible
            exerciseView.style.display = 'flex';
            exerciseView.classList.add('active');

            // Ensure loader is visible
            loader.style.display = 'flex';
            cameraPermission.style.display = 'none';

            // Reset flags
            cameraReady = false;
            firstPoseResultReceived = false;
        }

        // Initialize exercise monitoring
        function initializeExercise() {
            // Initialize MediaPipe Pose only if not already initialized
            if (!pose) {
                initializeMediaPipe();
            }

            // Initialize WebSocket connection
            initializeWebSocket();

            // Show mobile info panel on mobile devices
            if (window.innerWidth <= 768) {
                const mobileInfoPanel = document.querySelector('.mobile-info-panel');
                if (mobileInfoPanel) {
                    mobileInfoPanel.style.display = 'block';
                }
            }
        }

        // Initialize MediaPipe Pose
        function initializeMediaPipe() {
            const canvasCtx = poseCanvas.getContext('2d');

            pose = new Pose({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
            });

            // UPDATED: Set model complexity to 0 and confidence to 0.7
            pose.setOptions({
                modelComplexity: 0,
                smoothLandmarks: true,
                enableSegmentation: false,
                smoothSegmentation: false,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            pose.onResults(onPoseResults);

            // Initialize camera only if not already initialized
            if (!camera) {
                // Mobile-optimized camera constraints
                const constraints = {
                    video: {
                        facingMode: 'user', // Front camera for selfies
                        width: { ideal: 640, max: 1280 }, // Good balance of quality and performance
                        height: { ideal: 480, max: 720 }
                    }
                };

                camera = new Camera(cameraStream, {
                    onFrame: async () => {
                        try {
                            // Only process frames if exercise is active
                            if (exerciseActive) {
                                await pose.send({ image: cameraStream });
                            }
                        } catch (error) {
                            console.error('Error processing frame:', error);
                        }
                    }
                });

                camera.start(constraints)
                    .then(() => {
                        console.log('Camera started successfully');

                        const waitForVideo = setInterval(() => {
                            if (cameraStream.videoWidth > 0 && cameraStream.videoHeight > 0) {
                                clearInterval(waitForVideo);

                                // Set canvas dimensions to match the actual video stream
                                poseCanvas.width = cameraStream.videoWidth;
                                poseCanvas.height = cameraStream.videoHeight;
                                poseCanvas.style.width = '100%';
                                poseCanvas.style.height = '100%';

                                // Set a timeout to hide loader if no pose results are received after 5 seconds
                                setTimeout(() => {
                                    if (!firstPoseResultReceived) {
                                        console.log('No pose results received after 5 seconds, hiding loader anyway');
                                        loader.style.display = 'none';
                                        cameraReady = true;
                                    }
                                }, 5000);
                            }
                        }, 100);
                    })
                    .catch(error => {
                        console.error('Camera error:', error);
                        loader.style.display = 'none';
                        cameraPermission.style.display = 'block';
                    });
            }
        }

        // Detect camera jerk
        function detectCameraJerk(currentKeypoints, previousKeypoints) {
            if (!previousKeypoints) return false;

            // Calculate movement for each keypoint
            const movements = [];
            let totalMovement = 0;
            let validPoints = 0;

            for (let i = 0; i < currentKeypoints.length; i++) {
                if (currentKeypoints[i][3] > 0.5 && previousKeypoints[i][3] > 0.5) {
                    const dx = currentKeypoints[i][0] - previousKeypoints[i][0];
                    const dy = currentKeypoints[i][1] - previousKeypoints[i][1];
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    movements.push(distance);
                    totalMovement += distance;
                    validPoints++;
                }
            }

            if (validPoints === 0) return false;

            // Calculate average movement and standard deviation
            const avgMovement = totalMovement / validPoints;

            // Calculate standard deviation
            let variance = 0;
            for (const movement of movements) {
                variance += Math.pow(movement - avgMovement, 2);
            }
            const stdDev = Math.sqrt(variance / movements.length);

            // Camera jerk detection:
            // 1. High average movement across all points
            // 2. Low standard deviation (all points moving similarly)
            // This indicates the whole frame moved, suggesting camera jerk
            return avgMovement > cameraJerkThreshold && stdDev < avgMovement * 0.4;
        }

        // Process pose results
        function onPoseResults(results) {
            // Only hide loader when we get the first pose result
            if (!firstPoseResultReceived && results.poseLandmarks) {
                firstPoseResultReceived = true;
                loader.style.display = 'none';
                cameraReady = true;
                console.log('First pose result received, camera is ready');
            }

            let canvasCtx = null;
            try {
                canvasCtx = poseCanvas.getContext('2d');
                const currentTimestamp = Date.now();

                canvasCtx.save();
                canvasCtx.clearRect(0, 0, poseCanvas.width, poseCanvas.height);

                canvasCtx.drawImage(results.image, 0, 0, poseCanvas.width, poseCanvas.height);

                if (results.poseLandmarks) {
                    missingFrames = 0;

                    if (!personDetected) {
                        personDetected = true;
                        formStatus.textContent = "OK";
                        formStatus.className = "status good";
                        feedbackText.textContent = "Person detected";
                    }

                    drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
                    drawLandmarks(canvasCtx, results.poseLandmarks, { color: '#FF0000', lineWidth: 1, radius: 3 });

                    const keypoints = results.poseLandmarks.map(landmark => [
                        landmark.x,
                        landmark.y,
                        landmark.z || 0,
                        landmark.visibility || 1.0
                    ]);

                    // Check if whole body is visible
                    const bodyVisible = isWholeBodyVisible(results.poseLandmarks);

                    // Update whole body detection state
                    if (bodyVisible !== wholeBodyDetected) {
                        wholeBodyDetected = bodyVisible;
                        updateWholeBodyDetectionUI(wholeBodyDetected);
                    }

                    // Check for camera jerk
                    const detectedJerk = detectCameraJerk(keypoints, lastKeypoints);

                    if (detectedJerk && !isCameraJerk) {
                        isCameraJerk = true;
                        jerkRecoveryFrames = JERK_RECOVERY_COUNT;
                        console.log("Camera jerk detected - ignoring frames");
                    }

                    // Handle jerk recovery
                    if (isCameraJerk) {
                        jerkRecoveryFrames--;
                        if (jerkRecoveryFrames <= 0) {
                            isCameraJerk = false;
                            console.log("Camera jerk recovery complete");
                        }
                    }

                    // Send keypoints if whole body is visible and not in jerk recovery mode
                    if (wholeBodyDetected && !isCameraJerk) {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            data = JSON.stringify({
                                type: "keypoints",
                                keypoints: keypoints,
                                exercise: exerciseName
                            })
                            ws.send(JSON.stringify({
                                type: "keypoints",
                                keypoints: keypoints,
                                exercise: exerciseName
                            }));
                        }
                    } else {
                        console.log(`Ignoring frame: ${!wholeBodyDetected ? 'whole body not visible' : 'camera jerk'}`);
                    }

                    lastKeypoints = keypoints;
                    lastFrameTimestamp = currentTimestamp;

                } else {
                    missingFrames++;
                    lastKeypoints = null;
                    lastFrameTimestamp = null;
                    isCameraJerk = false;
                    jerkRecoveryFrames = 0;
                    wholeBodyDetected = false;
                    updateWholeBodyDetectionUI(false);

                    if (missingFrames >= MISSING_THRESHOLD && personDetected) {
                        personDetected = false;
                        handleNoPersonDetected();
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: "no_person" }));
                        }
                    }
                }

                canvasCtx.restore();
            } catch (error) {
                console.error('Error in onPoseResults:', error);
                // Ensure canvas is restored even if there's an error
                if (canvasCtx) {
                    try {
                        canvasCtx.restore();
                    } catch (e) {
                        console.error('Error restoring canvas context:', e);
                    }
                }
            }
        }

        // Update whole body detection UI
        function updateWholeBodyDetectionUI(isVisible) {
            if (isVisible) {
                personDetectionOverlay.classList.remove('active');
                cameraStream.classList.remove('blur');
                poseCanvas.classList.remove('blur');
                overlayActive = false;
            } else {
                personDetectionOverlay.classList.add('active');
                cameraStream.classList.add('blur');
                poseCanvas.classList.add('blur');
                overlayActive = true;
                
                // Stop timer if running and this is a plank exercise
                if (timerRunning && isPlankExercise) {
                    stopTimer();
                }
            }
        }

        // Handle no person detected
        function handleNoPersonDetected() {
            formStatus.textContent = "NO PERSON";
            formStatus.className = "status bad";
            feedbackText.textContent = "No person detected";

            // Update mobile UI
            const mobileFormStatus = document.getElementById('form-status-mobile');
            const mobileFeedbackText = document.getElementById('feedback-text-mobile');

            if (mobileFormStatus) {
                mobileFormStatus.textContent = "NO PERSON";
                mobileFormStatus.className = "bad";
            }

            if (mobileFeedbackText) {
                mobileFeedbackText.textContent = "No person detected";
            }
            
            // Stop timer if running
            if (timerRunning && isPlankExercise) {
                stopTimer();
            }
        }

        // Initialize WebSocket connection
        function initializeWebSocket() {
            const wsUrl = `${API_BASE_URL.replace(/^http/, 'ws')}/ws?session_id=${sessionId}`;
            //logToMobileConsole('Connecting to WebSocket', { url: wsUrl });
            
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                //logToMobileConsole('WebSocket connected successfully');
                resetExerciseState();
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    //logToMobileConsole('WebSocket message received', data);
                    updateUI(data);
                } catch (error) {
                    //logToMobileConsole('WebSocket parse error', { error: error.message });
                    console.error("WebSocket parse error:", error);
                }
            };

            ws.onclose = (event) => {
                //logToMobileConsole('WebSocket closed', { 
                //    code: event.code, 
                    reason: event.reason 
                //});
                
                // Only reconnect if exercise is still active
                if (exerciseActive) {
                   // logToMobileConsole('Attempting to reconnect...');
                    setTimeout(initializeWebSocket, 2000);
                }
            };

            ws.onerror = (error) => {
                logToMobileConsole('WebSocket error', { 
                    message: error.message || 'Unknown error' 
                });
                console.error("WebSocket error:", error);
            };
        }
        

        // Format time in MM:SS format
        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Update timer display
        function updateTimerDisplay() {
            if (isPlankExercise) {
                repCounter.textContent = formatTime(elapsedTime);
                const mobileRepCounter = document.getElementById('rep-counter-mobile');
                if (mobileRepCounter) {
                    mobileRepCounter.textContent = formatTime(elapsedTime);
                }
            }
        }

        // Start timer
        function startTimer() {
            if (!isPlankExercise || timerRunning || overlayActive) return;
            
            timerRunning = true;
            lastTimerUpdate = Date.now();
            
            timerInterval = setInterval(() => {
                const now = Date.now();
                const deltaTime = now - lastTimerUpdate;
                elapsedTime += deltaTime;
                lastTimerUpdate = now;
                updateTimerDisplay();
            }, 100); // Update every 100ms for smooth display
        }

        // Stop timer
        function stopTimer() {
            if (!isPlankExercise || !timerRunning) return;
            
            timerRunning = false;
            clearInterval(timerInterval);
        }

        // Update UI with exercise data
        function updateUI(data) {
            // Log the received data for debugging
            if (window.innerWidth <= 768) {
                console.log('Mobile UI update called with:', data);
            }
            
            if (data.exercise) {
                const mobileExerciseName = document.getElementById('exercise-name-mobile');
                if (mobileExerciseName) {
                    mobileExerciseName.textContent = data.exercise;
                }
            }
            
            // Handle timer for plank exercises
            if (isPlankExercise && data.feedback !== undefined) {
                const feedbackTextLower = data.feedback.toLowerCase();
                
                // Check if feedback is one of the valid plank feedbacks
                const isValidPlankFeedback = validPlankFeedbacks.some(feedback => 
                    feedbackTextLower.includes(feedback.toLowerCase())
                );
                
                if (isValidPlankFeedback && !overlayActive) {
                    if (!timerRunning) {
                        startTimer();
                    }
                } else {
                    if (timerRunning) {
                        stopTimer();
                    }
                }
            }
            
            if (data.reps !== undefined && !isPlankExercise) {
                // Update desktop counter for non-plank exercises
                repCounter.textContent = data.reps;
                
                // CRITICAL FIX FOR MOBILE
                const mobileRepCounter = document.getElementById('rep-counter-mobile');
                if (mobileRepCounter) {
                    // Force DOM refresh on mobile
                    if (window.innerWidth <= 768) {
                        // Method 1: Direct text update with animation
                        mobileRepCounter.classList.add('pulse');
                        mobileRepCounter.textContent = data.reps;
                        
                        // Method 2: Force reflow by accessing offsetHeight
                        void mobileRepCounter.offsetHeight;
                        
                        // Method 3: Remove and re-add element to force refresh
                        const parent = mobileRepCounter.parentNode;
                        const clone = mobileRepCounter.cloneNode(true);
                        clone.textContent = data.reps;
                        parent.replaceChild(clone, mobileRepCounter);
                        
                        // Clean up animation
                        setTimeout(() => {
                            const newElement = document.getElementById('rep-counter-mobile');
                            if (newElement) newElement.classList.remove('pulse');
                        }, 1000);
                    } else {
                        // Desktop update
                        mobileRepCounter.textContent = data.reps;
                        mobileRepCounter.classList.add('pulse');
                        setTimeout(() => mobileRepCounter.classList.remove('pulse'), 1000);
                    }
                } else {
                    console.error('Mobile rep counter element not found!');
                }
            }
            
            if (data.form_ok !== undefined) {
                if (personDetected) {
                    const statusText = data.form_ok ? "OK" : "FIX";
                    formStatus.textContent = statusText;
                    formStatus.className = "status " + (data.form_ok ? "good" : "bad");

                    const mobileFormStatus = document.getElementById('form-status-mobile');
                    if (mobileFormStatus) {
                        mobileFormStatus.textContent = statusText;
                        mobileFormStatus.className = data.form_ok ? "good" : "bad";
                    }
                }
            }
            
            if (data.feedback !== undefined) {
                if (personDetected) {
                    feedbackText.textContent = data.feedback || "No feedback yet";

                    // Add animation for feedback changes
                    feedbackText.style.opacity = '0';
                    setTimeout(() => {
                        feedbackText.style.transition = 'opacity 0.5s ease';
                        feedbackText.style.opacity = '1';
                    }, 100);

                    const mobileFeedbackText = document.getElementById('feedback-text-mobile');
                    if (mobileFeedbackText) {
                        mobileFeedbackText.textContent = data.feedback || "No feedback yet";

                        // Add animation for feedback changes
                        mobileFeedbackText.style.opacity = '0';
                        setTimeout(() => {
                            mobileFeedbackText.style.transition = 'opacity 0.5s ease';
                            mobileFeedbackText.style.opacity = '1';
                        }, 100);
                    }
                }
            }
        }

        // Stop exercise function
        let exerciseStopped = false;
        function stopExercise() {
            window.ReactNativeWebView.postMessage(JSON.stringify({ event: "stop_exercise" }))
            if (exerciseStopped) return;
            exerciseStopped = true;
            exerciseActive = false; // Set exercise as inactive

            // Stop timer if running
            if (timerRunning) {
                stopTimer();
            }

            // Close WebSocket connection
            if (ws) {
                if (ws.readyState === WebSocket.OPEN) {
                    //logToMobileConsole('Closing WebSocket connection');
                    ws.close(1000, "Exercise stopped by user");
                }
                ws = null;
            }

            // Clear overlay and blur
            personDetectionOverlay.classList.remove('active');
            cameraStream.classList.remove('blur');
            poseCanvas.classList.remove('blur');

            if (camera) {
                camera.stop();
                camera = null;
            }

            // Call API to stop exercise
            fetch(`${API_BASE_URL}/stop?session_id=${sessionId}`, {
                method: "POST",
                headers: { 'Content-Type': 'application/json' }
            })
                .then(response => {
                    console.log('Stop API response:', response);
                    return response.json();
                })
                .catch(error => console.error('Error stopping exercise:', error))
                .finally(() => {
                    // Redirect to a clean URL without parameters
                    window.history.replaceState({}, document.title, window.location.pathname);

                    // Show error message that exercise has ended
                    showError("Exercise has ended.");
                    window.location.href = '/';
                    exerciseStopped = false;
                });
        }

        /*function createMobileDebugConsole() {
            // Only create on mobile devices
            if (window.innerWidth > 768) return;
            
            // Remove existing console if it exists
            const existingConsole = document.getElementById('mobile-debug-console');
            if (existingConsole) {
                existingConsole.remove();
            }
            
            const debugConsole = document.createElement('div');
            debugConsole.id = 'mobile-debug-console';
            debugConsole.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                width: 320px;
                max-height: 250px;
                overflow-y: auto;
                background: rgba(0, 0, 0, 0.95);
                color: #00ff00;
                padding: 12px;
                border-radius: 8px;
                font-family: monospace;
                font-size: 12px;
                z-index: 10000;
                border: 2px solid #00ff00;
                box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
            `;
            
            // Add close button
            const closeBtn = document.createElement('div');
            closeBtn.textContent = '×';
            closeBtn.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                cursor: pointer;
                font-size: 18px;
                color: #ff0000;
                font-weight: bold;
            `;
            closeBtn.onclick = () => debugConsole.style.display = 'none';
            debugConsole.appendChild(closeBtn);
            
            // Add title
            const title = document.createElement('div');
            title.textContent = 'WebSocket Data';
            title.style.cssText = `
                font-weight: bold;
                margin-bottom: 10px;
                color: #00ffff;
                border-bottom: 1px solid #00ff00;
                padding-bottom: 5px;
                text-align: center;
            `;
            debugConsole.appendChild(title);
            
            // Add to page
            document.body.appendChild(debugConsole);
            
            // Store reference
            window.mobileDebugConsole = debugConsole;
            
            // Log that debug console is ready
            logToMobileConsole('Debug console initialized');
        }

        function logToMobileConsole(message, data = null) {
            if (!window.mobileDebugConsole || window.innerWidth > 768) return;
            
            const logEntry = document.createElement('div');
            logEntry.style.cssText = `
                margin-bottom: 8px;
                padding: 5px;
                background: rgba(0, 50, 0, 0.7);
                border-radius: 4px;
                border-left: 3px solid #00ff00;
            `;
            
            const timestamp = new Date().toLocaleTimeString();
            let logContent = `<div style="color: #ffff00; font-size: 10px;">${timestamp}</div>`;
            logContent += `<div style="color: #ffffff; margin-top: 3px;">${message}</div>`;
            
            if (data) {
                // Format JSON data nicely
                let formattedData;
                if (typeof data === 'object') {
                    formattedData = JSON.stringify(data, null, 2);
                } else {
                    formattedData = String(data);
                }
                logContent += `<div style="color: #00ccff; margin-top: 5px; font-size: 11px; white-space: pre-wrap;">${formattedData}</div>`;
            }
            
            logEntry.innerHTML = logContent;
            
            // Add to console
            window.mobileDebugConsole.appendChild(logEntry);
            
            // Auto scroll to bottom
            window.mobileDebugConsole.scrollTop = window.mobileDebugConsole.scrollHeight;
            
            // Keep only last 15 entries
            while (window.mobileDebugConsole.children.length > 18) { // 15 + title + close btn
                window.mobileDebugConsole.removeChild(window.mobileDebugConsole.children[2]); // Skip title and close btn
            }
        }*/

    </script>
</body>
</html>